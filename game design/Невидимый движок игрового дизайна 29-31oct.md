 Любая игра состоит из трех основных элементах:
 1) математика - это физика и геометрия игрового мира
 2) Логика - это мозг и правила определяющие поведение игрового мира
 3) Вероятность - живость добавляющая непредсказуемости игровому миру


# Векторы и матрицы: язык игрового пространства

*вектор* - это не просто точка, это:
-  позиция vector3(x,y,z)
- направление vector3(forvard**X**,forvard**Y**,forvard**Z**)
- скорость vector3(vel**X**, vel**Y**, vel**Z**)

*Матрицы* - преобразователи
- поворот - поворачивают игрока при движении мыши
- масштабирование - увеличивают или уменьшают объект
- смещение - перемещают объект в пространстве

# Производные и интегралы

### движение и физика 
производная = скорость изменения, в играх же это скорость и ускорение.
интеграл = накопление изменения. в играх это пройденный путь или общая нанесенная энергия


производная позиции = скорость
производная скорости = ускорение(гравитация)
движок чтобы получить скорость интегрирует ускорение, и интегрирует ускорение чтобы получить новую позицию


# Плавность и контроль в играх (интерполяция и кривые)

LERP - linear interpolation - плавный переход между двумя значениями `Lerp(A,B,t)` A,B - точки t -время

Кривые безье - позволяет создать сложные нелинейные пути и траектории

применяют для плавного перемещения камеры, гонок, создания гоночных трасс


# Баланс и прогресс игры

Баланс не искусство, а математика

типы функций роста:
- линейная: `уровень = уровень * базовая_цена` просто и скучно
- квадратичная: `уровень = базовая_цена * уровень^2` много гринда
- логарифмическая = быстрый рост в начале, после плато

# Игровое взаимодействие 

типы коллайдеров
- AABB - просто прямоугольник, быстрый, но не точный
- Сфера - идеален для шарообразных объектов
- капсула - хорош для персонажей
- mesh Collider - точный, но нагруженный коллайдер, коллайдер в виде самой модели
- raycast - бросок луча для проверки линии видимости или выстрела

## ИИ противника 
**FSN** - логическая модель где у объекта есть набор состояний и переходов между ними

Состояние: патрулирование преследование атака отступление

переходы с условиями: (увидел игрока -> преследование) (мало здоровья -> отступление)
Простота реализации делает FSN самым популярным инструмента для ИИ

BT - Behavior tree состоит из узлов которые выполняются сверху вниз, слева на право

типы узлов - 
- **selector(?)** - выполняет дочерние узлы пока один из них не будет выполнен успешно
- **Sequence(->)** - выполняет дочерние узлы пока все из них не совершатся успешно
- **decorator** - модифицирует поведение дочерних узлов
- **leaf** - выполняет одно конкретное действие


# Логика игрового мира: условия и квесты

Игровой мир управляется булевой логикой

например:
дверь откроется если игрок имеет ключ, или имеет навык взлома > 5
достижение откроется если убито 10 боссов и сложность сложная

системы визуального скриптинга(в UnrealEngine например) делают эту систему доступной для дизайнеров

# Процедурная генерация ландшафта и генерация контента

**методы**:
- BSP - рекурсивное разделение пространства для создания лабиринтов
- Шум Перлина - Генерация правдоподобных нерукотворных ландшафтов и текстур

Генерация должна обеспечивать проходимость

# Вероятность и дроп: управление вознаграждением

 - распределение Бернулли: простой шанс на выпадение предмета
 - взвешенные проценты дроп таблица где у каждого предмета своя таблица веса предмета (шанса выпадения)
 - Псевдо случайность - Системы которые увеличивают шанс срабатывания если не везет, до тех пор пока не повезет, потом снова исходный шанс 

# Критический урон и баланс

мат ожидания критического урона $БазУрон*(1-ШансКрита)+(БазУрон*КритМнож)*ШансКрита$ 
	 или
 $БазУрон*(1+ШансКрита*(КритМнож-1))$



## Необязательный аргумент

C# позволяет сделать аргумент в методе не обязательным задав ему значение по умолчанию
__значения по умолчанию должны идти в конце__

```cs
void start(string a, string b = "барабарабара")
{
    Console.WriteLine(a,b);
}
start("asd")//второй аргумент можно не вводить

void summ(int f = 0, int s = 0, int t = 0)
{
    Console.WriteLine(f+s+t);
}
summ(1, 2, 3);// 6
summ();// 0
```

## Передача параметров по имени

Для передачи параметров в произвольном порядке существует инструмент "передача аргумента по имени параметра"

Если при передачи параметров по имени нарушена очередность параметров, то все последующие аргументы также передаются по имени

```cs
void start(string a, string b = "барабарабара")
{
    Console.WriteLine(a,b);
}
start(b: "asd")// мы обратились к аргументу b
```

### params

`params` - модификатор позволяющий передавать в метод неограниченное 1 и более количество аргументов. 
	Передаваемые аргументы будут помещены в общий для них массив

Аргумент с модификатором params может быть только один, и в конце

(можно также передать сразу массив, но только один)

```cs
int kassir(int cost,params int[] money)
{
    int sum = 0;
    foreach (int i in money) { sum += i; }
    return  sum-cost;
}

Console.WriteLine(kassir(1000,200,50,100,100,100,500));//50 сдача


int[] mass = {200,50,100,100,100,500}
Console.WriteLine(kassir(1000,mass));//50 сдача


//оба варианта ввода парметров одинаково работают

```


## Модификаторы `ref \ in \ out`

`ref` - модификатор указывающий что значение будет выдано не по указанному значению, а по ссылке, и работа в методе будет происходить над теми данными которые можно найти по этой ссылке

```cs
void Metod(ref int x)
{
    x += 10;
    Console.WriteLine(x);
}
int data = 10;

Metod(ref data);//20
Console.WriteLine(data);//20 тк, число стало ссылочным
```

```cs
void SecMetod(int[] arr)
{
    arr = new int[3] {1,2,3};
    Console.WriteLine(string.Join(',',arr));
}

int[] data2 = { 1, 2 };
SecMetod(data2);//1,2,3
Console.WriteLine(string.Join(',', data2));//1,2

// не смотря на то что массив ссылочный тип данных, значение меняется, 
//(вроде как мы заменяем одну ссылку на другую поэтому оно работает не так как
//было)

//НО с помощью ref... 

void SecMetod(ref int[] arr)
{
    arr = new int[3] {1,2,3};
    Console.WriteLine(string.Join(',',arr));
}

int[] data2 = { 1, 2 };
SecMetod(ref data2); //1,2,3
Console.WriteLine(string.Join(',', data2)); //1,2,3

// (мы присваеваем ссылку ссылке хехе)
```


`in` - модификатор указывающий что значение будет выдано не по указанному значению, а по ссылке, но изменять это значение нельзя (только для чтения)
```cs
void Vopros3(in int a)
{
    a += 10;
}//выдает ошибку тк in только для чтения (своеобразная защита от дурака)
```


`out` - модификатор означает что в метод будет передана ссылка на область память (переменную)  куда нужно будет записать некоторое значение, в теле метода во все параметры с модификатором out обязательно должно быть записано значение


```cs
void OutOfHere(out int a, out int b)
{
    a = 0;
    b = 1;
}
int a;
int b;
OutOfHere(out a, out b);
Console.WriteLine(a+" "+b);

Console.WriteLine(int.TryParse("123",out b));
//если получилось перевести переводит и возвращает true, иначе b = 0, и выводит false
```

```cs

void OutOfHere(out int a, out int b)
{
    a = 0;
    b = 1;
}
int a;
int b;
OutOfHere(out a, out b);
```
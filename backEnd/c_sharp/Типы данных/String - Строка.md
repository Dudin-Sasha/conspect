string - тип данных | строка - объект 

строка - ==неизменяемая== упорядоченная пронумерованная последовательность символов
значения строк в c# объявляются двойными кавычками

```cs
string str = "asdasd";
Console.WriteLine(str[1]); // s
Console.WriteLine(str[^1]); // d

```

после .net 6 появились многострочные строки - для обозначения которых используют 3 пары двойных кавычек
```cs
string str = 
""" asdas+dsas """;

string stroka = "asdf\ngh"; // тут будет asdf на одной строке и ngh на другой
```
в этом случае если вывести значение по индексу переноса, то мы и получим символ переноса( ==\n== )

со строкой работает foreach и for, также у символов строки есть индексы, и соответственно длина `str.Lenght`

### конкатенация

конкатенация - конец одной строки приклеивается к началу другой - string + string

`string.concat(str1, str2)`- перезаписывает строку конкатенируя две строки (str1 и str2), также работает и с массивами - передавать можно набор значений через запятую (неограниченно), либо массив. Если передан массив то каждое его значение то к значению применяется ToString,

```cs
string num = "123";
string numSec = "456";
Console.WriteLine(num+numSec); //123456

Console.WriteLine(string.Сoncat(num, numSec)); //123456
Console.WriteLine( string.Сoncat(string[]{"a"+"b"}) ); // ab
```
 
 `ToString()` метод есть у всех объектов в c#, конвертирует ваше значение в новую строку
 
У ссылочных(массив) типов данных свои правила форматирования с этим методом
```cs
Console.WriteLine(string.Concat(new int[]{1,2},"1"));
// System.Int32[]1

```

###  join

метод `string.join` возвращает новую строку соединяя значение по тому же принципу что и `concat`, но на месте склейки дает возможность указать разделитель
Он принимает первым аргументом разделитель, последующими либо массив либо наборы аргументов через запятую
```cs
string str = "появился значит в зоне черный сталкер";
Console.WriteLine(string.Join(",", str,"123","654"));
//появился значит в зоне черный сталкер,123,654
```


### Split

Split - возвращает новый элемент строк элементы которого были разделены разделителем в строке
```cs

string str = "появился значит, в зоне черный сталкер";
Console.WriteLine(
    str.Split(",")[0] + '\n' +
    str.Split(",")[1]
    );

// появился значит,
//в зоне черный сталкер
```

### Insert

принимает два значения первый куда вставлять значение, второй что вставлять в строку 
возвращает новую строку с результатом вставки
```cs
string a = "да сколько можно";
Console.WriteLine(a.Insert(16,"!!"));
//да сколько можно!!
```

### Replace

принимает два значения первое какой символ заменять, второй что заменять в строке 
возвращает новую строку с результатом замены

```cs
string a = "да сколько можно";
Console.WriteLine(a.Replace("о","0"));
//да ск0льк0 м0жн0
```

### Trim

Возвращает новую строку где с начала и с конца строки удалены все символы из набора, до тех пор пока не встретит символ которого в наборе нет

*по умолчанию пробел*

TrimStart - работает с  только начала
TrimEnd - работает с только конца

```cs
string a = "   да сколько можно   ";
Console.WriteLine(a.Trim());
//да сколько можно

string a = "да сколько можноооо";
Console.WriteLine(a.Trim('о','д'));
//а сколько можн
```

### substring | remove 

 удаляется выделенное - remove
 удаляется все кроме выделенного - substring

принимают индекс начала строки(выделения), и опционально сколько символов в подстроке (сколько надо выделить), если не передавать второй параметр то выделение идёт до конца строки

```cs

string a = "да сколько можно";
Console.WriteLine(a.Substring(3,8));// сколько
Console.WriteLine(a.Substring(3));// сколько можно

Console.WriteLine(a.Remove(3, 8));// да можно
Console.WriteLine(a.Remove(3));// да


```

### Contains

проверяет есть ли в коллекции определенный элемент
да - true | нет - false
в строках ищет подстроку
```cs
string s1 = "aaaaBBBB";
Console.WriteLine(s1.Contains("aaa"));// true
```

### indexOf 

принимает до трех параметров 
1) что мы ищем
2) с какого индекса ищем (опционально)
3) сколько символов (тоже опционально)

если элемент найден возвращает его индекс, иначе возвращает -1
```cs
string s1 = "aaaaBBBB";
Console.WriteLine(s1.IndexOf("aB"));//3
```


LastIndexOff аналогичен IndexOf, но ищет последнее вхождение элемента подcтроки в строку

### ToUpper | ToLower

переводит все символы строки в верхний | нижний регистр

```cs
string s1 = "dFGhjkL!HGhfgd!gCv";
	Console.WriteLine(s1.ToUpper());//DFGHJKL!HGHFGD!GCV
	Console.WriteLine(s1.ToLower());//dfghjkl!hghfgd!gcv
```

